{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let digiliraPay = base58'4snGCeL4Wjopx9awWd7pfdqUYyN1CLqbPz66bn7VY8oe'
let gateway = base58'ActWMpdeyp8YHRhLxXmwdJmr37VXGgb44m8DuSVJW3k1'

let sponsorToken = base58'HLfv6YiY1ZpDktcKL9R79FTcez9WdMjaeMWxhREGcAqr'
let paymentToken = base58'HDBmVe4MFyVdh1Jy48m9XqXiHAVuNbwFB8dPskVMHS6B'
let recoveryToken = base58'HL1XtTLSdKMxB8LrkRYszqwtiSRepGTBBdnyrCqgaEVX'
let proxyWaves = base58'WAVES'

let recovery1 = base58'2tKRd22A8nkVNjtgT7JJxqSR8D9EA2RfsprJt35jw8Hr'
let recovery2 = base58'9cxzRSwiomyztUboaxherWQUUMGqZ3yX2nYrUa6XR9bT'
let recovery3 = base58'BCAaT65dW2nviLrwdqtoWFJP9D8z3576qFYKkHQ4wxPt'

let banned = 403000
let KYCPending = 0

let nonFungibleBlock = 50
let digiliraPayOnly = 99
let transferBlock = 100
let paymentBlock = 200
let paymentFundBlock = 300
let fundBlock = 400
let upperBlock = 500

func recovery(w: TransferTransaction | SetScriptTransaction | DataTransaction) = {
    let s1 = if(sigVerify(tx.bodyBytes, tx.proofs[0], recovery1 )) then 1 else 0
    let s2 = if(sigVerify(tx.bodyBytes, tx.proofs[1], recovery2 )) then 1 else 0
    let s3 = if(sigVerify(tx.bodyBytes, tx.proofs[2], recovery3 )) then 1 else 0

    if (s1 + s2 + s3 >= 2) then {
        true 
    } else {
        throw("Unauthorized")
    }
}

func transfer(w: TransferTransaction, lowerLimit: Int, upperLimit: Int, isAsset: Int|Unit, isUser: Int|Unit, myStatus: Int|Unit) = {

    if (isUser == -1 && (w.feeAssetId == sponsorToken || w.feeAssetId == paymentToken)) then {
        throw("This fee token cannot be used for transfering tokens to non DigiliraPay users")
    } else {
        if (isDefined(isAsset)) then {
            if (isAsset == banned || myStatus == banned || isUser == banned) then {
                throw("This asset cannot be transfered.")

            } else if ((lowerLimit <= valueOrElse(isAsset,0) && upperLimit > valueOrElse(isAsset,0)))  then { # is asset eligible

                if (valueOrElse(isUser,0) >= valueOrElse(isAsset,banned) && valueOrElse(myStatus,0) >= valueOrElse(isAsset,banned)) then { # is recipient eligible
                    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey) 
                } else {
                    throw("To transfer this asset user permission must be set correctly.")
                }

            } else {
                throw("Transfer is not available right now.")
            }
        } else {
            sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)  # not defined - any coin
        }
    }
}

match (tx) {
    case w:TransferTransaction  =>
        let myStatus = getInteger(addressFromPublicKey(digiliraPay), toBase58String(w.sender.bytes))
        let isUser =  getInteger(addressFromPublicKey(digiliraPay), toBase58String(addressFromRecipient(w.recipient).bytes))

        let isAsset =  getInteger(addressFromPublicKey(digiliraPay), toBase58String(valueOrElse(w.assetId, proxyWaves)))

        if (isDefined(isUser)) then { # is recipient a DP user
            if (w.recipient == addressFromPublicKey(gateway)) then {
                if (w.feeAssetId == paymentToken) then {  # payment block
                    transfer(w, digiliraPayOnly, fundBlock, isAsset, isUser, myStatus)
                } else if (w.feeAssetId == recoveryToken && myStatus == banned) then {  
                    recovery(w) # fund recovery block
                } else { 
                    throw("Transfer is not available right now.")
                } 
            } else { 
                transfer(w, digiliraPayOnly, upperBlock, isAsset, isUser, myStatus) # any other feeasset block
            }
        } else {
            transfer(w, transferBlock, paymentFundBlock, isAsset, -1, myStatus)  # is recipient is not digilirapay user
        }
    case t:SetScriptTransaction | DataTransaction =>
        recovery(t)
    case x:MassTransferTransaction | BurnTransaction | LeaseTransaction | Order | ExchangeTransaction => 
        false
    case _ =>
        false
 }
